{
  "tiddlers": [
    {
      "title": "$BackupDataFunctions",
      "text": "/**\n * ## Description\n * Backup your data to [JSONBIN.io](https://jsonbin.io)\n */\n/**\n * ## Data\n * ```json\n * {\n *   \"version\": 1.1.0\n * }\n * ```\n */\n// ## Code\n// ```javascript\ntw.macros.backup = {\n  // TODO: This is a plugin but it's icons are in core!\n  restoreButton() {\n    return tw.ui.button('{{$IconRestore}}', 'backup.restore', null, 'restore', 'title=\"Restore Backup Data\"');\n  },\n  backupButton() {\n    return tw.ui.button('{{$IconBackup}}', 'backup.save', null, 'backup', 'title=\"Backup Data\"');\n  },\n  async restore() {\n    let settings = tw.call('getJSONObject', '$GeneralSettings');\n    if (!settings || !settings.backup?.JSONBin?.accessKey || !settings.backup?.JSONBin?.binId) return tw.ui.notify('No JSONBin accessKey/binId found in $GeneralSettings!', 'W');\n    let res = await fetch('https://api.jsonbin.io/v3/b/' + settings.backup.JSONBin.binId, {\n      headers: {\n        'X-Access-Key': settings.backup.JSONBin.accessKey,\n      },\n    });\n    if (!res.ok) return tw.ui.notify(`Restore failed '${res.status}' (see log)`, 'E');\n    let result = await res.json();\n    Object.assign(tw.tiddlers, result.record);\n    tw.events.send('reboot.soft');\n    tw.ui.notify('Restore complete!', 'S'); // Should we save/remind to save?\n  },\n  async save() {\n    let settings = tw.call('getJSONObject', '$GeneralSettings');\n    if (!settings || !settings.backup?.JSONBin?.accessKey || !settings.backup?.JSONBin?.binId) return tw.ui.notify('No JSONBin accessKey/binId found in $GeneralSettings!', 'W');\n    let body = JSON.stringify({\n      all: tw.tiddlers.all,\n      visible: tw.tiddlers.visible,\n      // trashed: tw.tiddlers.trashed,\n    });\n    let res = await fetch('https://api.jsonbin.io/v3/b/' + settings.backup.JSONBin.binId, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Access-Key': settings.backup.JSONBin.accessKey,\n      // 'X-Bin-Versioning': true, // Not available in Free JSONBin :-(\n      },\n      body,\n    });\n    // doesn't get caught by notify!! throw new Error('Backup failed: ' + res.statusText);\n    if (!res.ok) return tw.ui.notify(`Backup failed '${res.status}' (see log)`, 'E');\n    // let result = await res.json();\n    tw.ui.notify(`Backup complete! (${body.length / 1000} KB)`, 'S');\n  },\n};\ntw.events.subscribe('backup.save', tw.macros.backup.save);\ntw.events.subscribe('backup.restore', tw.macros.backup.restore);\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-09-18T07:54:56.0000000Z",
      "updated": "2024-10-04T20:35:45.9805507Z"
    },
    {
      "title": "$ButtonsFunctions",
      "text": "/**\n  * Buttons to Show/Hide Tiddlers:\n  * Examples:\n  *  - Show all tiddlers\n  *    <<button Click Me!;ui.open.all>>\n  */\ntw.macros.button = (title, msg, payload = '', id = '') => {\n  return tw.ui.button(title, msg, payload, id);\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-09-18T07:54:56.0000000Z",
      "updated": "2024-10-04T19:45:16.1906502Z"
    },
    {
      "title": "$CoreThemeManager",
      "text": "/**\n * ## Description\n * Provides all theme logic\n * Provides <<ThemeSelector>> widget\n */\n/**\n * ## Data\n * ```json\n * {\n *   \"version\": 1.0.1\n * }\n * ```\n */\n(function(){\n\n  wireUp('ui.loaded', () => {\n    tw.theme = {\n      stylesheets: {\n        custom: new CSSStyleSheet(),\n      },\n      getThemeNames,\n    };\n    document.adoptedStyleSheets.push(tw.theme.stylesheets.custom);\n    themeUpdate();\n  });\n\n  wireUp('tiddler.updated', (t) => {\n    if (tiddlerIsThemeRelevant(t.title))\n      return themeUpdate();\n    if (tiddlerIsATheme(t.title))\n      return themesUpdate();\n  });\n\n  wireUp('theme.switch', themeSwitch);\n  function themeSwitch(theme) {\n    if (!theme) return;\n    if (!tw.call('tiddlerExists', theme)) return tw.ui.notify(`Unknown theme tiddler '${theme}'!`, 'E');\n    let tiddler = tw.run.getTiddler('$Theme');\n    tiddler.text = `[[${theme}]]`;\n    delete tiddler.doNotSave;\n    tw.run.updateTiddlerHard('$Theme', tiddler);\n    if (theme.match(/Dark/)) tw.dom.disableStyleSheet('highlight-light');\n    else tw.dom.disableStyleSheet('highlight-dark');\n    tw.events.send('tiddler.refresh', '$Theme');\n    themeUpdate(theme);\n    tw.events.send('save.silent');\n  }\n\n  wireUp('ui.reloaded', themeUpdate);\n  function themeUpdate() {\n    let css = getThemeStyleSheets().map(tw.run.getTiddlerTextRaw).join('\\n');\n    tw.theme.stylesheets.custom.replaceSync(css);\n  }\n\n  function tiddlerIsATheme(title) {\n    return tw.run.getTiddler(title)?.tags.includes('$Theme');\n  }\n\n  function themesUpdate() {\n    tw.events.send('tiddler.refresh', '$Themes');\n  }\n\n  function tiddlerIsThemeRelevant(title) {\n    let themeName = getCurrentThemeName();\n    return title === '$Theme' || title === themeName || getThemeStyleSheets().includes(title);\n  }\n  function getCurrentThemeName() {\n    return tw.run.getTiddlerTextRaw('$Theme').replace(/[\\[\\]]/g, ''); // Remove possible [[links]]\n  }\n  function getThemeNames() {\n    return tw.run.getTiddlersByTag('$Theme').map(t => t.title);\n  }\n  function getThemeStyleSheets() {\n    let theme = getCurrentThemeName();\n    if (!tw.call('tiddlerExists', theme)) {\n      tw.ui.notify('Unable to determine theme name from $Theme tiddler! Falling back on $CoreTheme', 'W');\n      theme = '$CoreTheme';\n    }\n    return tw.run.getTiddlerList(theme);\n  }\n\n  tw.macros.std.ThemeSelector = () => {\n    let theme = getCurrentThemeName();\n    return `<select id=\"theme-select\" onchange=\"tw.events.send('theme.switch', this.value);\">\n    ${getThemeNames().map(n => `<option value=\"${n}\"${n === theme ? ' selected' : ''}>${n.replace(/(^\\$)|(Theme$)/g, '')}</option>`).join('\\n')}\n  </select>`;\n  };\n\n  function wireUp(event, handler) {\n    tw.events.subscribe(event, handler, 'CoreThemeManager');\n  }\n})();\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-10-16T19:39:32.3065795Z",
      "updated": "2024-10-19T09:19:55.2898132Z"
    },
    {
      "title": "$GeneralWidgets",
      "text": "// Send any message\ntw.macros.std.SendMessage = (msg, payload = '') => {\n  return tw.ui.button(`Send: ${msg}:${payload}`, msg, payload, '', 'title=\"Send Message\"');\n};\n// Reload UI\ntw.macros.std.Reload = () => {\n  return tw.ui.button('🔄️', 'ui.reload', null, '', 'title=\"Reload\"');\n};\ntw.macros.std.Save = () => {\n  return tw.ui.button('{{$IconSave}}', 'save.all', null, '', 'title=\"Save\"');\n};\ntw.macros.std.Settings = () => {\n  return tw.ui.button('{{$IconSettings}}', 'tiddler.show', '$Settings', '', 'title=\"Settings\"');\n};\ntw.macros.std.New = () => {\n  return tw.ui.button('{{$IconNew}}', 'tiddler.new', null);\n};\n// Lists types used in all tiddlers\ntw.macros.std.AllTypesMacro = () => {\n  return tw.lib.markdown([...new Set(tw.tiddlers.all.map(t => `* [${t.type}](#msg:tiddlers.show:type:${t.type})\\n`))].join(''));\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-10-04T18:48:42.3651790Z",
      "updated": "2024-10-12T19:46:11.8225719Z"
    },
    {
      "title": "$GithubSaverExtension",
      "text": "tw.plugins.GitHubSaver = {\n  async save({text, token, repo, path, filename, commitMessage, branch, endpoint}) {\n    // \n    branch = branch || 'main';\n    endpoint = endpoint || 'https://api.github.com';\n    commitMessage = 'TWIKI Save ' + new Date().toISOString();\n\n    validate({text,token, repo, path, filename, commitMessage});\n\n    const headers = {\n      'Accept': 'application/vnd.github.v3+json',\n      'Content-Type': 'application/json;charset=UTF-8',\n      //'Authorization': 'Basic ' + btoa(username + ':' + password),\n      'Authorization': 'Bearer ' + token,\n      'If-None-Match': '',\n    };\n\n    // Normalize path with trailing slash\n    if (path.substring(0, 1) !== '/') path = '/' + path;\n    if (path.substring(path.length - 1) !== '/') path = path + '/';\n\n    // List Files\n    const listUrl = endpoint + '/repos/' + repo + '/contents' + path;\n    let res = await fetch(listUrl, {\n      method: 'GET',\n      headers: headers,\n      data: {\n        ref: branch,\n      },\n    });\n\n    if (res.ok) throw new Error(`GitHubSaver.save() GET files failed ${res.status} for ${listUrl}`);\n\n    // Find the sha of the file if it exists\n    const files = await res.json();\n    const sha = files.find(file => file.name === filename);\n\n    const data = {\n      message: commitMessage,\n      content: btoa(text),\n      branch: branch,\n      sha: sha,\n    };\n\n    // Perform a PUT request to save the file\n    let putUrl = listUrl + filename;\n    res = await fetch(putUrl, {\n      method: 'PUT',\n      headers: headers,\n      data: JSON.stringify(data),\n    });\n    if (res.ok) throw new Error(`GitHubSaver.save() PUT file failed ${res.status} for ${putUrl}`);\n\n    function validate(obj) {\n      Object.keys.forEach(k => {\n        if (!obj[k]) throw new Error(`GitHubSaver.save() missing parameter '${k}'!`);\n      });\n    }\n\n  },\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-10-04T19:45:16.1906502Z",
      "updated": "2024-10-04T19:45:16.1906502Z"
    },
    {
      "title": "$IncludeFunctions",
      "text": "/* eslint-disable no-eval */\n// Include the contents of another tiddler\n// <<include $TWIKIVersion>>\ntw.macros.include = (title) => {\n  // dp('include', title);\n  return tw.run.getTiddlerTextRaw(title);\n};\ntw.macros.eval = (code) => {\n  return eval(code);\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-09-18T07:54:56.0000000Z",
      "updated": "2024-09-18T07:54:56.0000000Z"
    },
    {
      "title": "$ListTiddlersWidgets",
      "text": "Object.assign(tw.macros.std, {\n  // List all tiddlers as a bulleted list\n  list({tag, title, pck, type} = {}) {\n    if (!title) title = '!^\\\\$'; // Hide system tiddlers by default\n    return tw.run.showTiddlerList(\n      tw.tiddlers.all\n        .filter(tw.util.titleMatch(title))\n        .filter(t => !pck || t.package === pck)\n        .filter(t => !type || t.type === type)\n        .filter(tw.util.tagMatch(tag)),\n    );\n  },\n  text (title) {\n    return tw.run.getTiddlerTextRaw(title);\n  },\n  Section ({name, content, message, payload, attr}) {\n    if (message) content = tw.events.send(message, payload)?.[0];\n    return tw.ui.section({name, content, attr});\n  },\n  Expand ({name, content, message, payload, attr}) {\n    if (message) content = tw.events.send(message, payload)?.[0];\n    return tw.ui.expand({name, content, attr});\n  },\n  // List all tiddlers on a single line with comma separation\n  AllTiddlersSimple (sep) {\n    return tw.lib.markdown(tw.tiddlers.all.map(t => t.title).join(sep || ', '));\n  },\n  // List all tags\n  AllTagsSimple (sep) {\n    if (!sep) sep = ', ';\n    let allTags = tw.macros.std.allTags();\n    return allTags.join(sep);\n  },\n  allTags () {\n    let tags = [];\n    tw.tiddlers.all.forEach(t => {\n      t.tags.filter(t => !!t).forEach(tag => {\n        tags.push(tag);\n      });\n    });\n    return [...new Set(tags)];\n  },\n  AllTagsLinked (sep) {\n    if (!sep) sep = ', ';\n    let allTags = tw.macros.std.allTags();\n    return tw.lib.markdown(\n      allTags.map(t => (`[${t}](#msg:ui.open.all:{\"tag\":\"${t}\",\"title\":\"*\"})`)).join(sep),\n    );\n  },\n});\n\ntw.events.subscribe('tiddlers.list', tw.macros.std.list);\ntw.events.subscribe('tiddler.text', tw.macros.std.text);\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-09-18T07:54:56.0000000Z",
      "updated": "2024-10-12T19:42:53.1491124Z"
    },
    {
      "title": "$NamespaceWidgets",
      "text": "tw.macros.std.NamespaceSelect = () => {\n  let namespace = tw.storage.get('namespace');\n  return `<select id=\"namespace-select\" onchange=\"tw.events.send('namespace.load.prompt', this.value);\">\n    <option value=\"\"> - new namespace -</option>\n    ${tw.storage.get('namespaces').map(n => `<option value=\"${n}\"${n === namespace ? ' selected' : ''}>${n}</option>`).join('\\n')}\n  </select>`;\n};\ntw.macros.std.NamespaceCreate = () => {\n  return tw.ui.button('Create Namespace', 'namespace.create.prompt');\n};\nif (!tw.tmp.namespaceEvents) {\n  tw.tmp.namespaceEvents = 1;\n  tw.events.subscribe('namespace.load.prompt', (namespace) => {\n    if (!namespace) namespace = tw.events.send('namespace.create.prompt')[0];\n    if (!namespace) return;\n    tw.events.send('namespace.load', namespace);\n  }, 'NamespaceWidgets');\n  tw.events.subscribe('namespace.create.prompt', () => {\n    let namespace = prompt('Enter name for new namespace:');\n    if (!namespace) return;\n    if (confirm('Would you like to clone this namespace?'))\n      tw.events.send('namespace.clone', namespace);\n    else\n      tw.events.send('namespace.create', namespace);\n    tw.dom.$('namespace-select').innerHTML = tw.macros.std.NamespaceSelect();\n    // tw.events.subscribe('tiddler.refresh', '$Namespaces'); // TODO: Dynamically get currentTiddler above?\n    return namespace;\n  }, 'NamespaceWidgets');\n}\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-10-04T19:45:16.1916481Z",
      "updated": "2024-10-11T20:18:45.8327330Z"
    },
    {
      "title": "$PackageWidgets",
      "text": "tw.macros.packages = {\n  // Example: Import package website without overwriting\n  // <<packages.import name:website url:./packages/website.json filter:* force:false>>\n  import({name, url, filter, overWrite, doNotSave}) {\n    if (!name) throw new Error('ERROR: No name supplied to packages.import macro!');\n    if (!url) throw new Error('ERROR: No url supplied to packages.import macro!');\n    return tw.ui.button(`Import: ${name} ${filter ? ' (' + filter + ')' : ''}`, 'package.reload.url', {url, name, overWrite, doNotSave});\n  },\n  importBin({name, url, filter, overWrite, doNotSave}) {\n    if (!name) throw new Error('ERROR: No name supplied to packages.importBin macro!');\n    if (!url) throw new Error('ERROR: No url supplied to packages.importBin macro!');\n    return tw.ui.button(`Import: ${name} ${filter ? ' (' + filter + ')' : ''}`, 'package.reload.bin', {url, name, overWrite, doNotSave});\n  },\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-10-04T18:48:42.3651790Z",
      "updated": "2024-10-19T09:44:42.0935910Z"
    },
    {
      "title": "$ShowTiddlersWidgets",
      "text": "/**\n  * Buttons to Show/Hide Tiddlers:\n  * Examples:\n  *  - Show all tiddlers tagged with Foo\n  *    <<ShowAllTiddlersButton tag:Foo>>\n  * -  Show all tiddlers not tagged with $Shadow\n  *    <<ShowAllTiddlersButton tag:!$Shadow>>\n  * - Show all tiddlers not tagged with $Shadow with title containing 'oo'\n  *    <<ShowAllTiddlersButton !$Shadow title:oo>>\n  * -  Show all tiddlers with title beginning with A\n  *   <<ShowAllTiddlersButton tag:*, title:^A>>\n  */\ntw.macros.std.ShowAllTiddlersButton = ({tag = '', title = ''} = {}) => {\n  return tw.ui.button('{{$IconOpenAll}}', 'ui.open.all', {tag, title}, 'close-all', 'title=\"Open All Tiddlers\"');\n};\n// Show all tiddlers with text (but really all)\ntw.macros.std.CloseAllTiddlersButton = ({tag = '*', title = '*'} = {}) => {\n  return tw.ui.button('{{$IconCloseAll}}', 'ui.close.all', {tag, title}, 'close-all', 'title=\"Close All Tiddlers\"');\n};\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-09-18T07:54:56.0000000Z",
      "updated": "2024-10-11T20:30:07.8061957Z"
    },
    {
      "title": "$SynchDataFunctions",
      "text": "/**\n * ## Description\n * $SynchDataFunctions\n * Synch your data with [JSONBIN.io](https://jsonbin.io)\n * ### Release Notes\n * * v1.0.7\n *   * Don't synch trashed tiddlers\n */\n/**\n * ## Data\n * ```json\n * {\n *   \"version\": 1.0.7\n * }\n * ```\n */\n// ## Code\n// ```javascript\n// TODO: Push force, clearing remote\n// TODO: Pull force, clearing local\n// TODO: Selective Synch: Include/Exclude Tags/Packages\ntw.macros.synch = (function(){\n  // TODO: Make events handler support asynch\n  // tw.events.subscribe('synch.full')\n  // onclick=tw.events.send(\\'synch.full\\')\n  return {\n    // <<synch.full>>: Push/pull to/from remote\n    full() {\n      return tw.ui.button('{{$IconSynch}}', 'synch.full', null, 'btn-synch', 'title=\"Synch Data\"');\n    },\n    async doFull() {\n      return await synch({pull: true, push: true});\n    },\n    // <<synch.test>>: Simulate push/pull to/from remote\n    test() {\n      return '<button onclick=\"tw.macros.synch.doTest()\">Synch Test</button>';\n    },\n    async doTest() {\n      return await synch({pull: true, push: true, dryRun: true});\n    },\n    // <<synch.pull>>: Only import from remote\n    pull() {\n      return '<button onclick=\"tw.macros.synch.doPull()\">Pull</button>';\n    },\n    async doPull() {\n      return await synch({pull: true, push: false});\n    },\n    // <<synch.push>>: Only write to remote\n    push() {\n      return '<button onclick=\"tw.macros.synch.doPush()\">Push</button>';\n    },\n    async doPush() {\n      return await synch({pull: false, push: true});\n    },\n    // TODO: Delete all remote and push (backup)\n    // TODO: Delete all local and pull (restore)\n  };\n\n  // eslint-disable-next-line complexity\n  async function synch({push = true, pull = true, dryRun = false}) {\n\n    if (!push && !pull) throw new Error('SynchDataFunctions: Please supply push or pull parameters!');\n\n    let settings = tw.call('getJSONObject', '$GeneralSettings');\n    if (!settings || !settings.synch?.JSONBin?.accessKey || !settings.synch?.JSONBin?.binId) return tw.ui.notify('No JSONBin accessKey/binId found in $GeneralSettings!', 'W');\n    let headers = {'X-Access-Key': settings.synch.JSONBin.accessKey};\n\n    // Fetch remote\n    let res = await fetch('https://api.jsonbin.io/v3/b/' + settings.synch.JSONBin.binId, {headers});\n    if (!res.ok) return tw.ui.notify(`Restore failed '${res.status}' (see log)`, 'E');\n    let result = await res.json();\n    let remoteTiddlers = result.record.tiddlers || [];\n    let remoteTrashedTiddlers = result.record.trashed || [];\n\n    let log = [];\n    let remote = {create: [], update: [], delete: []};\n    let local = {create: [], update: [], delete: []};\n\n    let localTiddlers = tw.tiddlers.all\n      .filter(t => !t.doNotSave) // Don't synch unsaveable content\n      .filter(t => !t.isRawShadow); // Don't synch raw shadows - See BUG below\n\n    // eslint-disable-next-line complexity\n    remoteTiddlers.forEach(remoteTiddler => {\n      remoteTiddler.created = new Date(remoteTiddler.created);\n      remoteTiddler.updated = new Date(remoteTiddler.updated);\n      let localTiddler = localTiddlers.find(t => t.title === remoteTiddler.title);\n      // TODO: Should we care if a trashed local tiddler has doNotSave?\n      // if (remoteTiddler.title.match(/SynchLog/)) debugger;\n      // TODO: BUG: Deleted local shadow tiddler is pulled in from remote\n      let deletedLocalTiddler = tw.tiddlers.trashed.find(t => t.title === remoteTiddler.title);\n      let deletedLocally = !localTiddler && deletedLocalTiddler?.updated > remoteTiddler.updated;\n      let createdRemotely = !localTiddler && !deletedLocally;\n      let updatedLocally = localTiddler?.updated > remoteTiddler.updated;\n      let updatedRemotely = remoteTiddler.updated > localTiddler?.updated;\n      if (deletedLocally) {\n        // Delete Remote\n        if (push) remote.delete.push(deletedLocalTiddler.title);\n      } else if (createdRemotely) {\n        // Restore Local: Updated remotely after local delete\n        if (pull) {\n          if (!dryRun) tw.run.addTiddler(remoteTiddler);\n          local.create.push(remoteTiddler.title);\n          log.push(`Created local tiddler [[${remoteTiddler.title}]]`);\n        }\n      } else if (updatedLocally) {\n        // Local update is newer\n        if (push) remote.update.push(localTiddler.title); // 👈\n      } else if (updatedRemotely) {\n        // Remote update is newer\n        if (push) {\n          if (!dryRun) tw.run.updateTiddlerHard(remoteTiddler.title, remoteTiddler);\n          local.update.push(remoteTiddler.title);\n          log.push(`Updated local tiddler [[${localTiddler.title}]]`); // 👈\n        }\n      }\n    });\n\n    localTiddlers.forEach(localTiddler => {\n      let remoteTiddler = remoteTiddlers.find(t => t.title === localTiddler.title);\n      if (remoteTiddler) {\n        remoteTiddler.created = new Date(remoteTiddler.created);\n        remoteTiddler.updated = new Date(remoteTiddler.updated);\n      }\n      let deletedRemoteTiddler = remoteTrashedTiddlers.find(t => t.title === localTiddler.title);\n      let deletedRemotely = !remoteTiddler && deletedRemoteTiddler?.updated > localTiddler.updated;\n      let createdLocally = !remoteTiddler && !deletedRemotely;\n      if (deletedRemotely) {\n        // Delete Locally\n        if (pull) {\n          if (!dryRun) tw.run.deleteTiddler(localTiddler.title, true);\n          local.delete.push(remoteTiddler.title);\n          log.push(`Deleted local tiddler [[${localTiddler.title}]]`);\n        }\n      } else if (createdLocally) {\n        if (push) remote.create.push(localTiddler.title);\n      }\n      // Updated locally/remotely handled above ☝️\n    });\n\n    if (remote.create.length + remote.update.length + remote.delete.length +\n      local.create.length + local.update.length + local.delete.length === 0\n    ) return tw.ui.notify('No changes to synch', 'S');\n\n    if (push) {\n      // Perform remote updates\n      remote.create.forEach(title => {\n        log.push(`Created remote tiddler [[${title}]]`);\n      });\n      remote.update.forEach(title => {\n        log.push(`Updated remote tiddler [[${title}]]`);\n      });\n      remote.delete.forEach(title => {\n        log.push(`Deleted remote tiddler [[${title}]]`);\n      });\n    }\n\n    let logTiddler = {\n      title: `$SynchLog ${new Date().toISOString()}`,\n      text: logSummary(local, remote) + '\\n\\n## Log\\n' + log.join('  \\n') + '',\n      tags: ['$SynchLog'],\n      type: 'x-twiki',\n    };\n\n    if (push && !dryRun) {\n      let body = JSON.stringify({\n        tiddlers: localTiddlers,\n        visible: tw.tiddlers.visible,\n      });\n      // We never push/pull trashed as this is local information (we read but never write it)\n      res = await fetch('https://api.jsonbin.io/v3/b/' + settings.synch.JSONBin.binId, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Access-Key': settings.synch.JSONBin.accessKey,\n        },\n        body,\n      });\n      // doesn't get caught by notify!! throw new Error('Backup failed: ' + res.statusText);\n      if (!res.ok) return tw.ui.notify(`Synch (push) to remote failed '${res.status}' (see log)`, 'E');\n    }\n\n    if (!dryRun) tw.events.send('reboot.softer');\n\n    if (push && pull) {\n      tw.ui.notify('Synch (full) complete!', 'S');\n    } else if (pull) {\n      tw.ui.notify('Synch (pull) complete!', 'S');\n    } else if (push) {\n      tw.ui.notify('Synch (push) complete!', 'S');\n    }\n\n    tw.run.previewTiddler(logTiddler);\n\n    function logSummary(local, remote) {\n      return `\n## Local\n* Created (${local.create.length}) ${local.create.length ? ':\\n  * [[' + local.create.join(']]\\n  * [[') + ']]\\n' : ''}\n* Updated (${local.update.length}) ${local.update.length ? ':\\n  * [[' + local.update.join(']]\\n  * [[') + ']]\\n' : ''}\n* Deleted (${local.delete.length}) ${local.delete.length ? ':\\n  * [[' + local.delete.join(']]\\n  * [[') + ']]\\n' : ''}\n## Remote\n* Created (${remote.create.length}) ${remote.create.length ? ':\\n  * [[' + remote.create.join(']]\\n  * [[') + ']]\\n' : ''}\n* Updated (${remote.update.length}) ${remote.update.length ? ':\\n  * [[' + remote.update.join(']]\\n  * [[') + ']]\\n' : ''}\n* Deleted (${remote.delete.length}) ${remote.delete.length ? ':\\n  * [[' + remote.delete.join(']]\\n  * [[') + ']]\\n' : ''}\n`.trim();\n    }\n  }\n\n})();\nif (!tw.tmp.synchEvents) {\n  // HACK: To prevent duplicate handlers\n  tw.tmp.synchEvents = 1;\n  tw.events.subscribe('synch.full', 'tw.macros.synch.doFull');\n  tw.events.subscribe('synch.push', 'tw.macros.synch.doPush');\n  tw.events.subscribe('synch.pull', 'tw.macros.synch.doPull');\n}\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-10-04T19:45:16.1926481Z",
      "updated": "2024-10-11T19:58:40.2679667Z"
    },
    {
      "title": "$TiddlerSearchResult",
      "text": "* {{!!title}} ",
      "tags": [],
      "type": "x-twiki",
      "created": "2024-10-04T19:45:16.1926481Z",
      "updated": "2024-10-04T19:45:16.1926481Z"
    },
    {
      "title": "$TrashedTiddlersFunctions",
      "text": "(function(){\n  const moduleName = 'TrashedTiddlersFunctions';\n\n  tw.macros.std.TrashCanIcon = () => {\n    let count = tw.tiddlers.trashed.length;\n    return tw.ui.button('{{$IconDelete}}', 'tiddler.show', '$TrashManager', 'trashCanIcon', `title=\"${count} trashed tiddlers\"`);\n  // return `<a id=\"trashCanIcon\" href=\"#$TrashManager\">🗑️ (${count})</a>`;\n  };\n  tw.macros.std.TrashEmptyButton = () => {\n    return tw.ui.button('Empty Trash', 'tiddlers.trashed.empty', null, 'trashButton');\n  };\n  tw.macros.std.TrashCanStatus = () => {\n    return `<span id=\"trashStatus\">${tw.tiddlers.trashed.length} tiddlers in the [trash can](#$TrashedTiddlers)!`;\n  };\n  tw.run.emptyTrash = () => {\n    if (!confirm('Are you sure you want to permanently deleted your trashed tiddlers?')) return;\n    tw.tiddlers.trashed = [];\n    tw.run.trashCanRefresh();\n    tw.run.save();\n  };\n  tw.macros.std.TrashCanContents = () => {\n    const list = tw.tiddlers.trashed.map(t => (`<li><a href=\"#msg:tiddlers.trashed.preview:${t.title}\">${t.title}</a> <a title=\"Restore Tiddler\" href=\"#msg:tiddler.trashed.restore:${t.title}\">🚮</a></li>`)).join('\\n');\n    return `<ul id=\"trashContents\">${list}</ul>`;\n  };\n  tw.run.trashPreview = (title) => {\n    let tiddler = tw.tiddlers.trashed.find(t => t.title === title);\n    tw.run.previewTiddler(tiddler, tw.templates.TiddlerTrashed);\n  };\n  tw.run.removeTiddlerFromTrash = (title) => {\n    if (!confirm('Are you sure you want to permanently delete your trashed tiddler?')) return;\n    let tiddlerIndex = tw.tiddlers.trashed.findIndex(t => t.title === title);\n    tw.tiddlers.trashed.splice(tiddlerIndex, 1);\n    tw.run.trashCanRefresh();\n    tw.dom.preview.close();\n    tw.run.save();\n  };\n  tw.run.trashCanRefresh = () => {\n    if (tw.dom.$('trashContents')) tw.dom.$('trashContents').outerHTML = tw.lib.markdown(tw.macros.std.TrashCanContents());\n    if (tw.dom.$('trashCanIcon')) tw.dom.$('trashCanIcon').innerHTML = tw.macros.std.TrashCanIcon();\n    if (tw.dom.$('trashStatus')) tw.dom.$('trashStatus').outerHTML = tw.lib.markdown(tw.macros.std.TrashCanStatus());\n\n    tw.run.rerenderTiddler('$TrashedTiddlers');\n  };\n  tw.run.restoreTiddlerFromTrash = (title) => {\n    if (!confirm('Are you sure you want to restore your trashed tiddler? This may overwrite an existing tiddler!')) return;\n    let tiddler = tw.tiddlers.trashed.find(t => t.title === title);\n    tw.run.addTiddler(tiddler);\n    tw.run.reload();\n    // So styles, search list etc update\n    let tiddlerIndex = tw.tiddlers.trashed.findIndex(t => t.title === title);\n    tw.tiddlers.trashed.splice(tiddlerIndex, 1);\n    tw.run.trashCanRefresh();\n    tw.run.save();\n  };\n  tw.events.subscribe('tiddlers.trashed.empty', tw.run.emptyTrash, moduleName);\n  tw.events.subscribe('tiddler.deleted', tw.run.trashCanRefresh, moduleName);\n  tw.events.subscribe('tiddler.trashed.restore', tw.run.restoreTiddlerFromTrash, moduleName);\n  tw.events.subscribe('tiddler.trashed.destroy', tw.run.removeTiddlerFromTrash, moduleName);\n  tw.events.subscribe('tiddlers.trashed.preview', tw.run.trashPreview, moduleName);\n})();\n",
      "tags": [],
      "type": "script/js",
      "created": "2024-09-18T07:54:56.0000000Z",
      "updated": "2024-10-11T20:31:44.2975954Z"
    },
    {
      "title": "$TrashManager",
      "text": "<<TrashCanStatus>>\n<<TrashEmptyButton>>\n<<TrashCanContents>>",
      "tags": [],
      "type": "x-twiki",
      "created": "2024-09-16T21:35:11.0000000Z",
      "updated": "2024-09-16T21:35:11.0000000Z"
    },
    {
      "title": "Backup",
      "text": "Backup will push all data (including trashed tiddlers and the visible state) to a remote.\n* <<backup.backupButton>>: Backup data\n* <<backup.restoreButton>>: Restore all data (!will overwrite everything)\n\nNote: In case you mess up we routinely make a local backup - press F12 and check under Application - Local Data",
      "tags": [],
      "type": "x-twiki",
      "created": "2024-10-12T18:30:05.7439160Z",
      "updated": "2024-10-16T19:33:47.7878625Z"
    },
    {
      "title": "Synchronization",
      "text": "Synchronization replicates local changes to a remote defined in [[$GeneralSettings]]:\n* <<synch.test>>: Simulate a Synch\n* <<synch.full>>: Run full synch (pull+push)\n* <<synch.push>>: Push changes to remote\n* <<synch.pull>>: Pull changes from remote",
      "tags": [],
      "type": "x-twiki",
      "created": "2024-10-12T18:28:50.6535057Z",
      "updated": "2024-10-12T18:29:20.6997473Z"
    }
  ]
}
